<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SingleChronicleQueueStore.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenHFT/Chronicle-Queue</a> &gt; <a href="index.source.html" class="el_package">net.openhft.chronicle.queue.impl.single</a> &gt; <span class="el_source">SingleChronicleQueueStore.java</span></div><h1>SingleChronicleQueueStore.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016-2020 chronicle.software
 *
 * https://chronicle.software
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.openhft.chronicle.queue.impl.single;

import net.openhft.chronicle.bytes.MappedBytes;
import net.openhft.chronicle.bytes.MappedFile;
import net.openhft.chronicle.core.Jvm;
import net.openhft.chronicle.core.Maths;
import net.openhft.chronicle.core.annotation.UsedViaReflection;
import net.openhft.chronicle.core.io.AbstractCloseable;
import net.openhft.chronicle.core.io.Closeable;
import net.openhft.chronicle.core.pool.ClassAliasPool;
import net.openhft.chronicle.core.values.LongValue;
import net.openhft.chronicle.core.values.TwoLongValue;
import net.openhft.chronicle.queue.ChronicleQueue;
import net.openhft.chronicle.queue.RollCycle;
import net.openhft.chronicle.queue.impl.ExcerptContext;
import net.openhft.chronicle.queue.impl.WireStore;
import net.openhft.chronicle.wire.*;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.File;
import java.io.IOException;
import java.io.StreamCorruptedException;
import java.io.UncheckedIOException;
import java.util.Objects;
import java.util.concurrent.TimeUnit;

<span class="pc bpc" id="L45" title="1 of 2 branches missed.">public class SingleChronicleQueueStore extends AbstractCloseable implements WireStore {</span>
    static {
<span class="fc" id="L47">        ClassAliasPool.CLASS_ALIASES.addAlias(SCQIndexing.class);</span>
<span class="fc" id="L48">    }</span>

    @NotNull
    final SCQIndexing indexing;
    // retains the MappedBytes used by the MappedFile
    @NotNull
    private final LongValue writePosition;
    @NotNull
    private final MappedBytes mappedBytes;
    @NotNull
    private final MappedFile mappedFile;
    private final int dataVersion;
    @NotNull
    private final transient Sequence sequence;

    private int cycle;

    /**
     * used by {@link net.openhft.chronicle.wire.Demarshallable}
     *
     * @param wire a wire
     */
    @UsedViaReflection
<span class="fc" id="L71">    private SingleChronicleQueueStore(@NotNull WireIn wire) {</span>
<span class="pc bpc" id="L72" title="2 of 4 branches missed.">        assert wire.startUse();</span>
        try {
<span class="fc" id="L74">            writePosition = loadWritePosition(wire);</span>
<span class="fc" id="L75">            this.mappedBytes = (MappedBytes) wire.bytes();</span>
<span class="fc" id="L76">            this.mappedFile = mappedBytes.mappedFile();</span>
<span class="fc" id="L77">            mappedFile.reserve(this);</span>
<span class="fc" id="L78">            this.indexing = Objects.requireNonNull(wire.read(MetaDataField.indexing).typedMarshallable());</span>
<span class="fc" id="L79">            this.indexing.writePosition = writePosition;</span>
<span class="fc" id="L80">            this.sequence = new RollCycleEncodeSequence(writePosition, rollIndexCount(), rollIndexSpacing());</span>
<span class="fc" id="L81">            this.indexing.sequence = sequence;</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">            if (wire.bytes().readRemaining() &gt; 0) {</span>
<span class="fc" id="L83">                final int version = wire.read(MetaDataField.dataFormat).int32();</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">                this.dataVersion = version &gt; 1 ? 0 : version;</span>
<span class="fc" id="L85">            } else</span>
<span class="nc" id="L86">                this.dataVersion = 0;</span>

        } finally {
<span class="pc bpc" id="L89" title="2 of 4 branches missed.">            assert wire.endUse();</span>
        }
<span class="fc" id="L91">    }</span>

    /**
     * @param rollCycle    the current rollCycle
     * @param wireType     the wire type that is being used
     * @param mappedBytes  used to mapped the data store file
     * @param indexCount   the number of entries in each index.
     * @param indexSpacing the spacing between indexed entries.
     */
    public SingleChronicleQueueStore(@NotNull RollCycle rollCycle,
                                     @NotNull final WireType wireType,
                                     @NotNull MappedBytes mappedBytes,
                                     int indexCount,
<span class="fc" id="L104">                                     int indexSpacing) {</span>
<span class="fc" id="L105">        this.mappedBytes = mappedBytes;</span>
<span class="fc" id="L106">        this.mappedFile = mappedBytes.mappedFile();</span>
<span class="fc" id="L107">        mappedFile.reserve(this);</span>
<span class="fc" id="L108">        indexCount = Maths.nextPower2(indexCount, 8);</span>
<span class="fc" id="L109">        indexSpacing = Maths.nextPower2(indexSpacing, 1);</span>

<span class="fc" id="L111">        this.indexing = new SCQIndexing(wireType, indexCount, indexSpacing);</span>
<span class="fc" id="L112">        this.indexing.writePosition = this.writePosition = wireType.newTwoLongReference().get();</span>
<span class="fc" id="L113">        this.indexing.sequence = this.sequence = new RollCycleEncodeSequence(writePosition,</span>
<span class="fc" id="L114">                rollCycle.defaultIndexCount(),</span>
<span class="fc" id="L115">                rollCycle.defaultIndexSpacing());</span>
<span class="fc" id="L116">        this.dataVersion = 1;</span>
<span class="fc" id="L117">    }</span>

    @NotNull
    public static String dump(@NotNull String directoryFilePath) {
<span class="nc" id="L121">        return ChronicleQueue.singleBuilder(directoryFilePath).build().dump();</span>
    }

    private static WireOut intForBinding(ValueOut wireOut, final LongValue value) {
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        return value instanceof TwoLongValue ?</span>
<span class="pc" id="L126">                wireOut.int128forBinding(0L, 0L, (TwoLongValue) value) :</span>
<span class="nc" id="L127">                wireOut.int64forBinding(0L, value);</span>

    }

    private LongValue loadWritePosition(@NotNull WireIn wire) {

<span class="fc" id="L133">        final ValueIn read = wire.read(MetaDataField.writePosition);</span>

        final int code;
<span class="fc" id="L136">        final long start = wire.bytes().readPosition();</span>

        try {
<span class="fc" id="L139">            wire.consumePadding();</span>
<span class="fc" id="L140">            code = wire.bytes().uncheckedReadUnsignedByte();</span>
        } finally {
<span class="fc" id="L142">            wire.bytes().readPosition(start);</span>
        }

<span class="fc bfc" id="L145" title="All 2 branches covered.">        if (code == BinaryWireCode.I64_ARRAY) {</span>
<span class="fc" id="L146">            TwoLongValue result = wire.newTwoLongReference();</span>
            // when the write position is and array it also encodes the sequence number in the write position as the second long value
<span class="fc" id="L148">            read.int128(result);</span>
<span class="fc" id="L149">            return result;</span>
        }

<span class="fc" id="L152">        final LongValue result = wire.newLongReference();</span>
<span class="fc" id="L153">        read.int64(result);</span>
<span class="fc" id="L154">        return result;</span>

    }

    @NotNull
    @Override
    public File file() {
<span class="fc" id="L161">        return mappedFile.file();</span>
    }

    @NotNull
    @Override
    public String dump() {
<span class="fc" id="L167">        return dump(false);</span>
    }

    @NotNull
    @Override
    public String shortDump() {
<span class="nc" id="L173">        return dump(true);</span>
    }

    private String dump(boolean abbrev) {
<span class="fc" id="L177">        try (MappedBytes bytes = MappedBytes.mappedBytes(mappedFile)) {</span>
<span class="fc" id="L178">            bytes.readLimit(bytes.realCapacity());</span>
<span class="fc" id="L179">            final Wire w = WireType.BINARY.apply(bytes);</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">            if (dataVersion &gt; 0)</span>
<span class="fc" id="L181">                w.usePadding(true);</span>
<span class="fc" id="L182">            return Wires.fromSizePrefixedBlobs(w, abbrev);</span>
        }
    }

    @Override
    public String dumpHeader() {
<span class="nc" id="L188">        try (MappedBytes bytes = MappedBytes.mappedBytes(mappedFile)) {</span>
<span class="nc" id="L189">            int size = bytes.readInt(0);</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">            if (!Wires.isReady(size))</span>
<span class="nc" id="L191">                return &quot;not ready&quot;;</span>
<span class="nc" id="L192">            bytes.readLimit(Wires.lengthOf(size) + 4L);</span>
<span class="nc" id="L193">            return Wires.fromSizePrefixedBlobs(bytes);</span>
        }
    }

    @Override
    public long writePosition() {
<span class="fc" id="L199">        return this.writePosition.getVolatileValue();</span>
    }

    @NotNull
    @Override
    public WireStore writePosition(long position) {
<span class="fc" id="L205">        throwExceptionIfClosed();</span>

<span class="pc bpc" id="L207" title="2 of 4 branches missed.">        assert writePosition.getVolatileValue() + mappedFile.chunkSize() &gt; position;</span>
<span class="fc" id="L208">        writePosition.setMaxValue(position);</span>
<span class="fc" id="L209">        return this;</span>
    }

    /**
     * Moves the position to the index
     *
     * @param ec    the data structure we are navigating
     * @param index the index we wish to move to
     * @return whether the index was found for reading.
     */
    @Nullable
    @Override
    public ScanResult moveToIndexForRead(@NotNull ExcerptContext ec, long index) {
<span class="fc" id="L222">        throwExceptionIfClosed();</span>

        try {
<span class="fc" id="L225">            return indexing.moveToIndex(ec, index);</span>
<span class="nc" id="L226">        } catch (@NotNull UnrecoverableTimeoutException e) {</span>
<span class="nc" id="L227">            return ScanResult.NOT_REACHED;</span>
        }
    }

    @Override
    protected boolean threadSafetyCheck(boolean isUsed) {
        // disable thread safety check
<span class="fc" id="L234">        return true;</span>
    }

    @Override
    public long moveToEndForRead(@NotNull Wire w) {
<span class="fc" id="L239">        throwExceptionIfClosed();</span>

<span class="fc" id="L241">        return indexing.moveToEnd(w);</span>
    }

    @Override
    protected void performClose() {
<span class="fc" id="L246">        Closeable.closeQuietly(writePosition);</span>
<span class="fc" id="L247">        Closeable.closeQuietly(indexing);</span>

<span class="fc" id="L249">        mappedBytes.release(INIT);</span>
        try {
<span class="fc" id="L251">            mappedFile.release(this);</span>
<span class="nc" id="L252">        } catch (IllegalStateException e) {</span>
<span class="nc" id="L253">            e.printStackTrace();</span>
<span class="fc" id="L254">        }</span>
<span class="fc" id="L255">    }</span>

    /**
     * @return creates a new instance of mapped bytes, because, for example the tailer and appender
     * can be at different locations.
     */
    @NotNull
    @Override
    public MappedBytes bytes() {
<span class="fc" id="L264">        throwExceptionIfClosed();</span>

<span class="fc" id="L266">        return MappedBytes.mappedBytes(mappedFile);</span>
    }

    @Override
    public long sequenceForPosition(@NotNull final ExcerptContext ec, final long position, boolean inclusive) throws
            UnrecoverableTimeoutException, StreamCorruptedException {
<span class="fc" id="L272">        throwExceptionIfClosed();</span>

<span class="fc" id="L274">        return indexing.sequenceForPosition(ec, position, inclusive);</span>
    }

    @Override
    public long lastSequenceNumber(@NotNull ExcerptContext ec) throws StreamCorruptedException {
<span class="fc" id="L279">        throwExceptionIfClosedInSetter();</span>

<span class="fc" id="L281">        return indexing.lastSequenceNumber(ec);</span>
    }

    @NotNull
    @Override
    public String toString() {
<span class="nc" id="L287">        return &quot;SingleChronicleQueueStore{&quot; +</span>
                &quot;indexing=&quot; + indexing +
<span class="nc" id="L289">                &quot;, writePosition/seq=&quot; + writePosition.toString() +</span>
                &quot;, mappedFile=&quot; + mappedFile +
<span class="nc" id="L291">                &quot;, isClosed=&quot; + isClosed() +</span>
                '}';
    }

    // *************************************************************************
    // Marshalling
    // *************************************************************************

    @Override
    public void writeMarshallable(@NotNull WireOut wire) {
        ;
<span class="fc" id="L302">        ValueOut wireOut = wire.write(MetaDataField.writePosition);</span>
<span class="fc" id="L303">        intForBinding(wireOut, writePosition)</span>
<span class="fc" id="L304">                .write(MetaDataField.indexing).typedMarshallable(this.indexing)</span>
<span class="fc" id="L305">                .write(MetaDataField.dataFormat).int32(dataVersion);</span>
<span class="fc" id="L306">    }</span>

    @Override
    public void initIndex(@NotNull Wire wire) {
<span class="fc" id="L310">        throwExceptionIfClosedInSetter();</span>

        try {
<span class="fc" id="L313">            indexing.initIndex(wire);</span>
<span class="nc" id="L314">        } catch (IOException ex) {</span>
<span class="nc" id="L315">            throw new UncheckedIOException(ex);</span>
<span class="fc" id="L316">        }</span>
<span class="fc" id="L317">    }</span>

    @Override
    public boolean indexable(long index) {
<span class="nc" id="L321">        return indexing.indexable(index);</span>
    }

    @Override
    public void setPositionForSequenceNumber(@NotNull final ExcerptContext ec, long sequenceNumber,
                                             long position)
            throws UnrecoverableTimeoutException, StreamCorruptedException {
<span class="fc" id="L328">        throwExceptionIfClosedInSetter();</span>

<span class="fc" id="L330">        sequence.setSequence(sequenceNumber, position);</span>

<span class="fc" id="L332">        long nextSequence = indexing.nextEntryToBeIndexed();</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (nextSequence &gt; sequenceNumber)</span>
<span class="fc" id="L334">            return;</span>

<span class="fc" id="L336">        indexing.setPositionForSequenceNumber(ec, sequenceNumber, position);</span>

<span class="fc" id="L338">    }</span>

    @Override
    public ScanResult linearScanTo(final long index, final long knownIndex, final ExcerptContext ec, final long knownAddress) {
<span class="fc" id="L342">        throwExceptionIfClosed();</span>

<span class="fc" id="L344">        return indexing.linearScanTo(index, knownIndex, ec, knownAddress);</span>
    }

    @Override
    public boolean writeEOF(@NotNull Wire wire, long timeoutMS) {
<span class="fc" id="L349">        throwExceptionIfClosed();</span>

<span class="fc" id="L351">        String fileName = mappedFile.file().getAbsolutePath();</span>

        // just in case we are about to release this
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if (wire.bytes().tryReserve(this)) {</span>
            try {
<span class="fc" id="L356">                return writeEOFAndShrink(wire, timeoutMS);</span>

            } finally {
<span class="fc" id="L359">                wire.bytes().release(this);</span>
            }
        }

<span class="nc" id="L363">        try (MappedBytes bytes = MappedBytes.mappedBytes(mappedFile.file(), mappedFile.chunkSize())) {</span>
<span class="nc" id="L364">            Wire wire0 = WireType.valueOf(wire).apply(bytes);</span>
<span class="nc" id="L365">            return writeEOFAndShrink(wire0, timeoutMS);</span>

<span class="nc" id="L367">        } catch (Exception e) {</span>
<span class="nc" id="L368">            Jvm.warn().on(getClass(), &quot;unable to write the EOF file=&quot; + fileName, e);</span>
<span class="nc" id="L369">            return false;</span>
        }
    }

    boolean writeEOFAndShrink(@NotNull Wire wire, long timeoutMS) {
<span class="fc bfc" id="L374" title="All 2 branches covered.">        if (wire.writeEndOfWire(timeoutMS, TimeUnit.MILLISECONDS, writePosition())) {</span>
            // only if we just written EOF
<span class="fc" id="L376">            QueueFileShrinkManager.scheduleShrinking(mappedFile.file(), wire.bytes().writePosition());</span>
<span class="fc" id="L377">            return true;</span>
        }
<span class="fc" id="L379">        return false;</span>
    }

    @Override
    public int dataVersion() {
<span class="fc" id="L384">        return dataVersion;</span>
    }

    int rollIndexCount() {
<span class="fc" id="L388">        return indexing.indexCount();</span>
    }

    int rollIndexSpacing() {
<span class="fc" id="L392">        return indexing.indexSpacing();</span>
    }

    public SingleChronicleQueueStore cycle(int cycle) {
<span class="fc" id="L396">        throwExceptionIfClosedInSetter();</span>

<span class="fc" id="L398">        this.cycle = cycle;</span>
<span class="fc" id="L399">        return this;</span>
    }

    public int cycle() {
<span class="fc" id="L403">        return cycle;</span>
    }

    public File currentFile() {
<span class="nc" id="L407">        return mappedFile.file();</span>
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>