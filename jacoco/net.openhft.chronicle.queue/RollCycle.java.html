<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RollCycle.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenHFT/Chronicle-Queue</a> &gt; <a href="index.source.html" class="el_package">net.openhft.chronicle.queue</a> &gt; <span class="el_source">RollCycle.java</span></div><h1>RollCycle.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016-2020 chronicle.software
 *
 * https://chronicle.software
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.openhft.chronicle.queue;

import net.openhft.chronicle.core.time.TimeProvider;

public interface RollCycle {

    /**
     * Returns the format that is to be applied when file names are calculated for a new roll cycle.
     * &lt;p&gt;
     * For example, the following formats can be returned:
     * &lt;ul&gt;
     *     &lt;li&gt;&quot;yyyyMMdd-HHmm&quot; (MINUTELY)&lt;/li&gt;
     *     &lt;li&gt;&quot;yyyyMMdd&quot; (DAILY)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return the format that is to be applied when file names are calculated for a new roll cycle
     */
    String format();

    /**
     * Returns the length in milliseconds (i.e. the maximum duration) for a roll cycle.
     * &lt;p&gt;
     * For example, the following lengths can be returned:
     * &lt;ul&gt;
     *     &lt;li&gt;60 * 1,000 = 60,000 (MINUTELY)&lt;/li&gt;
     *     &lt;li&gt;24 * 60 * 60 * 1,000 = 86,400,000 (DAILY)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return the length in milliseconds (i.e. the maximum duration) for a roll cycle
     */
    int lengthInMillis();

    @Deprecated(/* to be removed in x.22 */)
    default int length() {
<span class="nc" id="L52">        return lengthInMillis();</span>
    }

    /**
     * @return the size of each index array, note: indexCount^2 is the maximum number of index queue entries.
     */
    int defaultIndexCount();

    /**
     * Returns the space between excerpts that are explicitly indexed.
     * &lt;p&gt;
     * A higher number means higher sequential write performance but slower random access read. The sequential read performance is not affected by
     * this property.
     * &lt;p&gt;
     * For example, the following default index spacing can be returned:
     * &lt;ul&gt;
     *     &lt;li&gt;16 (MINUTELY)&lt;/li&gt;
     *     &lt;li&gt;64 (DAILY)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return the space between excerpts that are explicitly indexed
     */
    int defaultIndexSpacing();

    /**
     * @param epoch and EPOCH offset, to all the user to define their own epoch
     * @return the cycle
     */
    int current(TimeProvider time, long epoch);

    /**
     * Returns the index for the given {@code cycle} and {@code sequenceNumber}.
     * &lt;p&gt;
     * An index is comprised of both a cycle and a sequence number but the way the index is composed of said properties may vary.
     *
     * @param cycle          to be composed into an index
     * @param sequenceNumber to be composed into an index
     * @return the index for the given {@code cycle} and {@code sequenceNumber}
     */
    long toIndex(int cycle, long sequenceNumber);

    /**
     * Returns the sequence number for the given {@code index}.
     * &lt;p&gt;
     * An index is comprised of both a cycle and a sequence number but the way the index is composed of said properties may vary. This method
     * decomposes the provided {@code index} and extracts the sequence number.
     *
     * @param index to use when extracting the sequence number
     * @return the sequence number for the given {@code index}
     */
    long toSequenceNumber(long index);

    /**
     * Returns the cycle for the given {@code index}.
     * &lt;p&gt;
     * An index is comprised of both a cycle and a sequence number but the way the index is composed of said properties may vary. This method
     * decomposes the provided {@code index} and extracts the cycle.
     *
     * @param index to use when extracting the cycle
     * @return the sequence number for the given {@code index}
     */
    int toCycle(long index);

    /**
     * @return the maximum number of messages per cycle
     */
    long maxMessagesPerCycle();

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>